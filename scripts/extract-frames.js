#!/usr/bin/env node

// scripts/extract-frames.js
// Extrator de frames OTIMIZADO - Desktop + Mobile
// ‚úÖ Ajustes:
// - For√ßa encoder est√°tico para WebP: -c:v libwebp (evita WebP animado)
// - Remove smart_subsample (ou deixa comentado)
// - Garante dimens√µes pares: mobile scale '768:-2'
// - Acrescenta format=yuv420p no filtro (compat)
// - Adiciona -vsync 0 para sequ√™ncia est√°vel
// - Bufferiza stderr do FFmpeg para logs de erro √∫teis
// üÜï NOVO: Suporte para m√∫ltiplas resolu√ß√µes com controle de tamanho

import { spawn } from 'child_process';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const rootDir = path.join(__dirname, '..');

class FrameExtractor {
  constructor() {
    // Base para os frames - sempre em static/img/frames
    this.outputBase = path.join(rootDir, 'static', 'img', 'frames');
    
    // Configura√ß√µes padr√£o otimizadas para performance
    this.defaultConfig = {
      fps: 15,           // 15 fps √© suficiente para scroll suave
      quality: 85,       // Qualidade boa mas n√£o exagerada
      desktopFormat: 'jpg',
      mobileFormat: 'webp'
    };

    // üÜï NOVO: Configura√ß√£o de breakpoints responsivos
    this.responsiveBreakpoints = {
      desktop: [
        { width: 2440, maxKB: 140, quality: 85, suffix: '_2440' },
        { width: 1920, maxKB: 120, quality: 82, suffix: '_1920' },
        { width: 1440, maxKB: 90,  quality: 80, suffix: '_1440' },
        { width: 1280, maxKB: 72,  quality: 78, suffix: '_1280' }
      ],
      mobile: [
        { width: 900,  maxKB: 60,  quality: 85, suffix: '_900' },
        { width: 650,  maxKB: 45,  quality: 82, suffix: '_650' },
        { width: 300,  maxKB: 40,  quality: 80, suffix: '_300' }
      ]
    };
  }

  /**
   * Verificar se ffmpeg est√° instalado
   */
  async checkFFmpeg() {
    return new Promise((resolve) => {
      const ffmpeg = spawn('ffmpeg', ['-version']);
      ffmpeg.on('error', () => resolve(false));
      ffmpeg.on('close', (code) => resolve(code === 0));
    });
  }

  /**
   * Extrair frames de um v√≠deo com foco em performance
   */
  async extractFrames(videoPath, outputDir, options = {}) {
    const {
      fps = this.defaultConfig.fps,
      quality = this.defaultConfig.quality,
      format = 'jpg',
      scale = null,
      startTime = null,
      duration = null,
      suffix = ''  // üÜï NOVO: Sufixo para m√∫ltiplas resolu√ß√µes
    } = options;

    // Criar diret√≥rio de sa√≠da
    await fs.mkdir(outputDir, { recursive: true });

    // Padr√£o de nome dos frames (com sufixo opcional)
    const outputPattern = path.join(outputDir, `frame_%04d${suffix}.${format}`);

    // Montar comando ffmpeg otimizado
    const args = [];
    
    // Decodifica√ß√£o r√°pida
    args.push('-hwaccel', 'auto');
    
    // Tempo inicial
    if (startTime) {
      args.push('-ss', startTime);
    }
    
    // Input
    args.push('-i', videoPath);
    
    // Dura√ß√£o
    if (duration) {
      args.push('-t', duration);
    }

    // Filtros de v√≠deo
    const filters = [`fps=${fps}`];
    if (scale) {
      filters.push(`scale=${scale}:flags=fast_bilinear`); // Scaling r√°pido
    }
    // Compatibilidade com encoders que exigem YUV420
    filters.push('format=yuv420p');
    args.push('-vf', filters.join(','));

    // Configura√ß√µes de qualidade otimizadas
    if (format === 'jpg' || format === 'jpeg') {
      // Converte 0-100 para 1-3 (aproxima√ß√£o de qualidade do mjpeg)
      args.push('-q:v', Math.max(1, Math.min(3, Math.round(quality / 33))).toString());
      // Codec padr√£o mjpeg √© ok
    } else if (format === 'webp') {
      // ‚ö†Ô∏è For√ßa encoder EST√ÅTICO para evitar WebP animado
      args.push('-c:v', 'libwebp');
      args.push('-lossless', '0');
      args.push('-quality', quality.toString());       // 0-100
      args.push('-compression_level', '4');            // 0-6 (4 √© mais r√°pido)
      args.push('-preset', 'picture');
      // args.push('-smart_subsample', '1'); // opcional, comente se seu build n√£o suportar
      // Sequ√™ncia est√°vel de arquivos (1 arquivo por frame)
      args.push('-vsync', '0');
      // Tamb√©m poder√≠amos for√ßar o pix_fmt aqui, mas j√° est√° no filtro:
      // args.push('-pix_fmt', 'yuv420p');
    }

    // Threading para acelerar
    args.push('-threads', '0'); // Usa todos os cores dispon√≠veis
    
    // Output
    args.push(outputPattern);

    console.log(`   üìπ Extraindo: ${path.basename(videoPath)}`);
    console.log(`      ‚Üí FPS: ${fps} | Qualidade: ${quality}% | Formato: ${format.toUpperCase()}`);
    if (scale) console.log(`      ‚Üí Resolu√ß√£o: ${scale}`);
    if (suffix) console.log(`      ‚Üí Sufixo: ${suffix}`);

    return new Promise((resolve, reject) => {
      const ffmpeg = spawn('ffmpeg', args);
      
      let lastFrame = 0;
      let startTimeMs = Date.now();
      let stderrBuf = '';

      ffmpeg.stderr.on('data', (data) => {
        const output = data.toString();
        stderrBuf += output;
        
        // Capturar progresso
        const frameMatch = output.match(/frame=\s*(\d+)/);
        if (frameMatch) {
          lastFrame = parseInt(frameMatch[1]);
          const elapsed = (Date.now() - startTimeMs) / 1000;
          const fpsNow = lastFrame / elapsed;
          process.stdout.write(`\r      ‚è≥ Frame ${lastFrame} (${fpsNow.toFixed(1)} fps)...`);
        }
      });

      ffmpeg.on('close', async (code) => {
        console.log(''); // Nova linha
        
        if (code !== 0) {
          console.error('----- FFmpeg stderr -----\n' + stderrBuf + '\n------------------------');
          reject(new Error(`FFmpeg falhou com c√≥digo ${code}`));
          return;
        }

        try {
          // Contar frames gerados
          const files = await fs.readdir(outputDir);
          const frames = files.filter(f => f.endsWith(`.${format}`)).sort();
          
          const elapsed = ((Date.now() - startTimeMs) / 1000).toFixed(1);
          console.log(`      ‚úÖ ${frames.length} frames em ${elapsed}s`);

          resolve({
            success: true,
            outputDir,
            frameCount: frames.length,
            frames: frames,
            elapsed: elapsed
          });
        } catch (err) {
          console.error('Erro ao ler diret√≥rio de sa√≠da:', err.message);
          reject(err);
        }
      });

      ffmpeg.on('error', (err) => {
        reject(err);
      });
    });
  }

  // üÜï NOVO: M√©todo para calcular qualidade ideal para atingir tamanho alvo
  async findOptimalQuality(videoPath, width, targetKB, format, fps) {
    let minQuality = 50;
    let maxQuality = 95;
    let optimalQuality = 75;
    let attempts = 0;
    const maxAttempts = 5;
    
    console.log(`      üéØ Buscando qualidade ideal para ${width}px (alvo: <${targetKB}KB)...`);
    
    while (attempts < maxAttempts && minQuality <= maxQuality) {
      attempts++;
      const testQuality = Math.round((minQuality + maxQuality) / 2);
      
      // Extrair frame de teste
      const testFile = path.join(this.outputBase, `test_${width}.${format}`);
      
      // Comando FFmpeg para extrair um frame de teste
      const args = [
        '-i', videoPath,
        '-vf', `scale=${width}:-2,select='eq(n\\,10)'`, // Frame 10 como amostra
        '-vframes', '1'
      ];
      
      if (format === 'jpg') {
        args.push('-q:v', Math.round(testQuality / 33).toString());
      } else if (format === 'webp') {
        args.push('-c:v', 'libwebp');
        args.push('-quality', testQuality.toString());
      }
      
      args.push('-y', testFile);
      
      const success = await new Promise((resolve) => {
        const ffmpeg = spawn('ffmpeg', args, { stdio: 'pipe' });
        ffmpeg.on('close', (code) => resolve(code === 0));
        ffmpeg.on('error', () => resolve(false));
      });
      
      if (success) {
        try {
          const stats = await fs.stat(testFile);
          const sizeKB = stats.size / 1024;
          
          console.log(`         Teste ${attempts}: Q${testQuality} = ${sizeKB.toFixed(1)}KB`);
          
          if (sizeKB <= targetKB) {
            optimalQuality = testQuality;
            minQuality = testQuality + 1;
            
            // Se est√° muito abaixo do alvo, podemos aumentar mais
            if (sizeKB < targetKB * 0.8) {
              minQuality = testQuality + 5;
            }
          } else {
            maxQuality = testQuality - 1;
          }
          
          // Limpar arquivo de teste
          await fs.unlink(testFile).catch(() => {});
        } catch (err) {
          // Ignorar erro
        }
      }
    }
    
    console.log(`      ‚úÖ Qualidade otimizada: ${optimalQuality}%`);
    return optimalQuality;
  }

  // üÜï NOVO: Processar v√≠deo com m√∫ltiplas resolu√ß√µes
  async processVideoResponsive(desktopVideo, mobileVideo, videoName, options = {}) {
    const {
      fps = this.defaultConfig.fps,
      skipSizes = [], // Array de widths para pular
      optimizeQuality = true // Se deve otimizar qualidade para tamanho alvo
    } = options;

    // Limpar nome
    const cleanName = videoName.replace(/[^a-z0-9]/gi, '_').toLowerCase();

    console.log('\n' + '='.repeat(70));
    console.log(`üé¨ PROCESSAMENTO RESPONSIVO: ${videoName}`);
    console.log('='.repeat(70));
    console.log(`‚ö° Gerando m√∫ltiplas resolu√ß√µes com controle de tamanho`);
    console.log(`üìä FPS: ${fps}`);

    const results = {
      desktop: {},
      mobile: {}
    };

    try {
      // 1. PROCESSAR VERS√ïES DESKTOP
      console.log('\nüñ•Ô∏è  VERS√ïES DESKTOP (m√∫ltiplas resolu√ß√µes):');
      
      for (const config of this.responsiveBreakpoints.desktop) {
        if (skipSizes.includes(config.width)) {
          console.log(`   ‚è≠Ô∏è  Pulando ${config.width}px`);
          continue;
        }
        
        const outputDir = path.join(this.outputBase, 'desktop', cleanName);
        
        console.log(`\n   üìê Processando ${config.width}px (m√°x ${config.maxKB}KB):`);
        
        // Otimizar qualidade se necess√°rio
        let finalQuality = config.quality;
        if (optimizeQuality) {
          finalQuality = await this.findOptimalQuality(
            desktopVideo, 
            config.width, 
            config.maxKB, 
            this.defaultConfig.desktopFormat,
            fps
          );
        }
        
        const result = await this.extractFrames(
          desktopVideo,
          outputDir,
          {
            fps,
            quality: finalQuality,
            format: this.defaultConfig.desktopFormat,
            scale: `${config.width}:-2`,
            suffix: config.suffix
          }
        );
        
        results.desktop[config.width] = result;
      }

      // 2. PROCESSAR VERS√ïES MOBILE
      console.log('\nüì± VERS√ïES MOBILE (m√∫ltiplas resolu√ß√µes):');
      
      for (const config of this.responsiveBreakpoints.mobile) {
        if (skipSizes.includes(config.width)) {
          console.log(`   ‚è≠Ô∏è  Pulando ${config.width}px`);
          continue;
        }
        
        const outputDir = path.join(this.outputBase, 'mobile', cleanName);
        
        console.log(`\n   üìê Processando ${config.width}px (m√°x ${config.maxKB}KB):`);
        
        // Otimizar qualidade se necess√°rio
        let finalQuality = config.quality;
        if (optimizeQuality) {
          finalQuality = await this.findOptimalQuality(
            mobileVideo, 
            config.width, 
            config.maxKB, 
            this.defaultConfig.mobileFormat,
            fps
          );
        }
        
        const result = await this.extractFrames(
          mobileVideo,
          outputDir,
          {
            fps,
            quality: finalQuality,
            format: this.defaultConfig.mobileFormat,
            scale: `${config.width}:-2`,
            suffix: config.suffix
          }
        );
        
        results.mobile[config.width] = result;
      }

      // 3. SALVAR CONFIGURA√á√ÉO
      const configPath = path.join(this.outputBase, `${cleanName}_responsive_config.json`);
      const configData = {
        name: cleanName,
        originalName: videoName,
        responsive: true,
        breakpoints: {
          desktop: this.responsiveBreakpoints.desktop.map(bp => ({
            width: bp.width,
            maxKB: bp.maxKB,
            frameCount: results.desktop[bp.width]?.frameCount || 0,
            suffix: bp.suffix
          })),
          mobile: this.responsiveBreakpoints.mobile.map(bp => ({
            width: bp.width,
            maxKB: bp.maxKB,
            frameCount: results.mobile[bp.width]?.frameCount || 0,
            suffix: bp.suffix
          }))
        },
        settings: { fps },
        processedAt: new Date().toISOString()
      };
      
      await fs.writeFile(configPath, JSON.stringify(configData, null, 2));

      // 4. RESUMO
      console.log('\n' + '='.repeat(70));
      console.log('‚úÖ PROCESSAMENTO RESPONSIVO CONCLU√çDO!');
      console.log('='.repeat(70));
      
      console.log('\nüìä RESUMO:');
      console.log(`   V√≠deo: ${cleanName}`);
      console.log(`   Desktop: ${Object.keys(results.desktop).length} resolu√ß√µes`);
      console.log(`   Mobile: ${Object.keys(results.mobile).length} resolu√ß√µes`);
      
      console.log('\nüíæ USO NO SCROLLYFRAMES:');
      console.log('```javascript');
      console.log('// Detectar largura e escolher resolu√ß√£o ideal');
      console.log('const width = window.innerWidth;');
      console.log('if (width <= 768) {');
      console.log(`  // Mobile: ${Object.keys(results.mobile).join(', ')}px`);
      console.log('} else {');
      console.log(`  // Desktop: ${Object.keys(results.desktop).join(', ')}px`);
      console.log('}');
      console.log('```');

      return { ...results, config: configData };

    } catch (error) {
      console.error('\n‚ùå Erro no processamento responsivo:', error.message);
      throw error;
    }
  }

  /**
   * Processar par de v√≠deos (desktop + mobile)
   */
  async processVideoPair(desktopVideo, mobileVideo, videoName, options = {}) {
    const {
      fps = this.defaultConfig.fps,
      quality = this.defaultConfig.quality,
      desktopScale = '1920:-2',  // Mant√©m AR e garante dimens√£o par
      mobileScale = '768:-2'      // Mant√©m AR e garante dimens√£o par
    } = options;

    // Validar nome
    if (!videoName || videoName.trim() === '') {
      throw new Error('Nome do v√≠deo √© obrigat√≥rio!');
    }

    // Limpar nome (remover caracteres especiais)
    const cleanName = videoName.replace(/[^a-z0-9]/gi, '_').toLowerCase();

    console.log('\n' + '='.repeat(60));
    console.log(`üé¨ PROCESSANDO: ${videoName}`);
    console.log('='.repeat(60));
    console.log(`‚ö° Modo: PERFORMANCE (${fps} fps, ${quality}% qualidade)`);

    const results = {};

    try {
      // Criar diret√≥rios
      const desktopDir = path.join(this.outputBase, 'desktop', cleanName);
      const mobileDir = path.join(this.outputBase, 'mobile', cleanName);

      // 1. DESKTOP - JPG otimizado
      console.log('\nüñ•Ô∏è  DESKTOP:');
      const desktopStart = Date.now();
      results.desktop = await this.extractFrames(
        desktopVideo,
        desktopDir,
        {
          fps,
          quality,
          format: this.defaultConfig.desktopFormat,
          scale: desktopScale
        }
      );

      // 2. MOBILE - WebP otimizado (est√°tico, 1 arquivo por frame)
      console.log('\nüì± MOBILE:');
      const mobileStart = Date.now();
      results.mobile = await this.extractFrames(
        mobileVideo,
        mobileDir,
        {
          fps,
          quality,
          format: this.defaultConfig.mobileFormat,
          scale: mobileScale
        }
      );

      // Tempo total
      const totalTime = ((Date.now() - desktopStart) / 1000).toFixed(1);

      // Resumo
      console.log('\n' + '='.repeat(60));
      console.log('‚úÖ CONCLU√çDO!');
      console.log('='.repeat(60));
      
      console.log('\nüìä RESUMO:');
      console.log(`   Nome: ${cleanName}`);
      console.log(`   FPS: ${fps}`);
      console.log(`   Qualidade: ${quality}%`);
      console.log(`   Desktop: ${results.desktop.frameCount} frames (${this.defaultConfig.desktopFormat.toUpperCase()})`);
      console.log(`   Mobile: ${results.mobile.frameCount} frames (${this.defaultConfig.mobileFormat.toUpperCase()})`);
      console.log(`   Tempo total: ${totalTime}s`);
      
      console.log('\nüìÅ ESTRUTURA GERADA:');
      console.log(`   static/img/frames/`);
      console.log(`   ‚îú‚îÄ‚îÄ desktop/`);
      console.log(`   ‚îÇ   ‚îî‚îÄ‚îÄ ${cleanName}/`);
      console.log(`   ‚îÇ       ‚îú‚îÄ‚îÄ frame_0001.${this.defaultConfig.desktopFormat}`);
      console.log(`   ‚îÇ       ‚îî‚îÄ‚îÄ ...`);
      console.log(`   ‚îî‚îÄ‚îÄ mobile/`);
      console.log(`       ‚îî‚îÄ‚îÄ ${cleanName}/`);
      console.log(`           ‚îú‚îÄ‚îÄ frame_0001.${this.defaultConfig.mobileFormat}`);
      console.log(`           ‚îî‚îÄ‚îÄ ...`);

      // Salvar configura√ß√£o
      const configPath = path.join(this.outputBase, `${cleanName}_config.json`);
      const config = {
        name: cleanName,
        originalName: videoName,
        desktop: {
          path: `/img/frames/desktop/${cleanName}/`,
          frameCount: results.desktop.frameCount,
          format: this.defaultConfig.desktopFormat,
          pattern: `frame_%04d.${this.defaultConfig.desktopFormat}`
        },
        mobile: {
          path: `/img/frames/mobile/${cleanName}/`,
          frameCount: results.mobile.frameCount,
          format: this.defaultConfig.mobileFormat,
          pattern: `frame_%04d.${this.defaultConfig.mobileFormat}`
        },
        settings: {
          fps,
          quality
        },
        processedAt: new Date().toISOString()
      };
      
      await fs.writeFile(configPath, JSON.stringify(config, null, 2));
      
      console.log('\nüíæ CONFIGURA√á√ÉO PARA O SCROLLYFRAMES:');
      console.log('```');
      console.log(`framePrefix="/img/frames/desktop/${cleanName}/frame_"`);
      console.log(`framePrefixMobile="/img/frames/mobile/${cleanName}/frame_"`);
      console.log(`totalFrames={${Math.min(results.desktop.frameCount, results.mobile.frameCount)}}`);
      console.log('```');

      return { ...results, config };

    } catch (error) {
      console.error('\n‚ùå Erro no processamento:', error.message);
      throw error;
    }
  }

  /**
   * Processar m√∫ltiplos pares de v√≠deos
   */
  async processBatch(videoPairs) {
    console.log('\nüé¨ PROCESSAMENTO EM LOTE');
    console.log(`üì¶ Total: ${videoPairs.length} pares de v√≠deos`);
    
    const results = [];
    
    for (let i = 0; i < videoPairs.length; i++) {
      const pair = videoPairs[i];
      console.log(`\n[${i + 1}/${videoPairs.length}] Processando: ${pair.name}`);
      
      try {
        const result = await this.processVideoPair(
          pair.desktop,
          pair.mobile,
          pair.name,
          pair.options || {}
        );
        results.push(result);
      } catch (error) {
        console.error(`‚ùå Falha em ${pair.name}:`, error.message);
        results.push({ error: error.message, name: pair.name });
      }
    }
    
    return results;
  }

  /**
   * Listar v√≠deos j√° processados
   */
  async listProcessed() {
    try {
      const desktopDir = path.join(this.outputBase, 'desktop');
      const mobileDir = path.join(this.outputBase, 'mobile');
      
      const desktopFolders = await fs.readdir(desktopDir).catch(() => []);
      const mobileFolders = await fs.readdir(mobileDir).catch(() => []);
      
      const processed = [];
      
      for (const folder of desktopFolders) {
        if (mobileFolders.includes(folder)) {
          const configPath = path.join(this.outputBase, `${folder}_config.json`);
          try {
            const config = JSON.parse(await fs.readFile(configPath, 'utf-8'));
            processed.push(config);
          } catch {
            processed.push({ name: folder });
          }
        }
      }
      
      return processed;
    } catch {
      return [];
    }
  }

  /**
   * Listar v√≠deos dispon√≠veis na pasta static/videos
   */
  async listAvailableVideos() {
    const videosDir = path.join(rootDir, 'static', 'videos');
    
    try {
      // Verificar se a pasta existe
      await fs.access(videosDir);
      
      // Listar arquivos
      const files = await fs.readdir(videosDir);
      
      // Filtrar apenas v√≠deos
      const videoFiles = files.filter(f => 
        f.match(/\.(mp4|webm|mov|avi|mkv)$/i)
      );
      
      // Agrupar por pares (desktop/mobile)
      const pairs = new Map();
      
      for (const file of videoFiles) {
        // Tentar identificar o nome base e o tipo
        let baseName, type;
        
        if (file.includes('_desktop') || file.includes('_wide')) {
          baseName = file.replace(/_desktop|_wide/i, '').replace(/\.[^.]+$/, '');
          type = 'desktop';
        } else if (file.includes('_mobile') || file.includes('_vertical')) {
          baseName = file.replace(/_mobile|_vertical/i, '').replace(/\.[^.]+$/, '');
          type = 'mobile';
        } else {
          // Arquivo sem sufixo claro
          baseName = file.replace(/\.[^.]+$/, '');
          type = 'unknown';
        }
        
        if (!pairs.has(baseName)) {
          pairs.set(baseName, {});
        }
        
        pairs.get(baseName)[type] = file;
      }
      
      return { videosDir, files: videoFiles, pairs };
      
    } catch (error) {
      if (error.code === 'ENOENT') {
        return { 
          videosDir, 
          files: [], 
          pairs: new Map(),
          error: 'Pasta static/videos n√£o encontrada'
        };
      }
      throw error;
    }
  }

  /**
   * Processar todos os pares de v√≠deos encontrados
   */
  async processAllVideos(options = {}) {
    const { pairs, videosDir } = await this.listAvailableVideos();
    
    if (pairs.size === 0) {
      console.log('Nenhum par de v√≠deos encontrado em static/videos/');
      return [];
    }
    
    const results = [];
    let processed = 0;
    
    for (const [baseName, files] of pairs) {
      if (files.desktop && files.mobile) {
        processed++;
        console.log(`\n[${processed}/${pairs.size}] Processando: ${baseName}`);
        
        try {
          const result = await this.processVideoPair(
            path.join(videosDir, files.desktop),
            path.join(videosDir, files.mobile),
            baseName,
            options
          );
          results.push({ name: baseName, ...result });
        } catch (error) {
          console.error(`‚ùå Erro em ${baseName}:`, error.message);
          results.push({ name: baseName, error: error.message });
        }
      }
    }
    
    return results;
  }
}

// ==== CLI ====
async function main() {
  const args = process.argv.slice(2);
  
  if (args.length === 0 || args[0] === '--help' || args[0] === '-h') {
    console.log(`
üé¨ EXTRATOR DE FRAMES OTIMIZADO PARA SCROLLYFRAMES

Uso:
  node extract-frames.js <desktop.mp4> <mobile.mp4> <nome> [op√ß√µes]
  node extract-frames.js --list-videos    Lista v√≠deos em static/videos/
  node extract-frames.js --list           Lista frames j√° processados
  node extract-frames.js --process-all    Processa todos os v√≠deos
  node extract-frames.js --responsive <desktop.mp4> <mobile.mp4> <nome>  üÜï NOVO

Op√ß√µes:
  --fps <n>          FPS (padr√£o: 15, recomendado: 10-20)
  --quality <n>      Qualidade 0-100 (padr√£o: 85)
  --desktop-scale    Resolu√ß√£o desktop (padr√£o: 1920:-2)
  --mobile-scale     Resolu√ß√£o mobile (padr√£o: 768:-2)
  --responsive       üÜï Gerar m√∫ltiplas resolu√ß√µes responsivas
  --skip <widths>    üÜï Pular resolu√ß√µes espec√≠ficas (ex: --skip 2440,300)

üÜï MODO RESPONSIVO:
  Gera 7 resolu√ß√µes diferentes com controle de tamanho:
  
  Desktop (JPG):
    ‚Ä¢ 2440px - m√°x 140KB por frame
    ‚Ä¢ 1920px - m√°x 120KB por frame
    ‚Ä¢ 1440px - m√°x 90KB por frame
    ‚Ä¢ 1280px - m√°x 72KB por frame
  
  Mobile (WebP):
    ‚Ä¢ 900px - m√°x 60KB por frame
    ‚Ä¢ 650px - m√°x 45KB por frame
    ‚Ä¢ 300px - m√°x 40KB por frame

Comandos Especiais:
  --list-videos      Mostra v√≠deos dispon√≠veis em static/videos/
  --list             Mostra frames j√° processados
  --process-all      Processa todos os pares de v√≠deos automaticamente
  --responsive       Processa com m√∫ltiplas resolu√ß√µes

Exemplos:
  # Processar v√≠deos da pasta static/videos/
  node extract-frames.js static/videos/intro_desktop.mp4 static/videos/intro_mobile.mp4 intro
  
  # Ver v√≠deos dispon√≠veis
  node extract-frames.js --list-videos
  
  # Processar TODOS os v√≠deos de uma vez
  node extract-frames.js --process-all --fps 15 --quality 85
  
  # üÜï MODO RESPONSIVO - M√∫ltiplas resolu√ß√µes
  node extract-frames.js --responsive desktop.mp4 mobile.mp4 hero
  node extract-frames.js --responsive desktop.mp4 mobile.mp4 hero --skip 2440,300
  
  # Performance m√°xima (10 fps, qualidade 70%)
  node extract-frames.js desktop.mp4 mobile.mp4 hero --fps 10 --quality 70
  
  # Alta qualidade (20 fps, qualidade 95%)
  node extract-frames.js desktop.mp4 mobile.mp4 hero --fps 20 --quality 95

Organiza√ß√£o Recomendada:
  static/videos/
  ‚îú‚îÄ‚îÄ intro_desktop.mp4    (ou intro_wide.mp4)
  ‚îú‚îÄ‚îÄ intro_mobile.mp4     (ou intro_vertical.mp4)
  ‚îú‚îÄ‚îÄ hero_desktop.mp4
  ‚îú‚îÄ‚îÄ hero_mobile.mp4
  ‚îî‚îÄ‚îÄ ...

Performance vs Qualidade:
  üöÄ R√ÅPIDO:     --fps 10 --quality 70  (recomendado para testes)
  ‚öñÔ∏è  BALANCEADO: --fps 15 --quality 85  (padr√£o, recomendado)
  üé® QUALIDADE:  --fps 20 --quality 95  (para produ√ß√£o)
  üé¨ CINEMA:     --fps 24 --quality 95  (m√°xima qualidade)
    `);
    process.exit(0);
  }

  // üÜï NOVO: Processar com m√∫ltiplas resolu√ß√µes
  if (args[0] === '--responsive') {
    if (args.length < 4) {
      console.error('‚ùå Uso: node extract-frames.js --responsive <desktop.mp4> <mobile.mp4> <nome>');
      process.exit(1);
    }
    
    const desktopVideo = args[1];
    const mobileVideo = args[2];
    const videoName = args[3];
    
    const options = {
      fps: 15,
      skipSizes: [],
      optimizeQuality: true
    };
    
    // Parse de op√ß√µes
    const fpsIndex = args.indexOf('--fps');
    if (fpsIndex > -1 && args[fpsIndex + 1]) {
      options.fps = parseInt(args[fpsIndex + 1]);
    }
    
    const skipIndex = args.indexOf('--skip');
    if (skipIndex > -1 && args[skipIndex + 1]) {
      options.skipSizes = args[skipIndex + 1].split(',').map(w => parseInt(w));
    }
    
    const extractor = new FrameExtractor();
    
    // Verificar ffmpeg
    const hasFFmpeg = await extractor.checkFFmpeg();
    if (!hasFFmpeg) {
      console.error('‚ùå FFmpeg n√£o encontrado!');
      console.error('   Mac: brew install ffmpeg');
      console.error('   Linux: sudo apt install ffmpeg');
      console.error('   Windows: https://ffmpeg.org/download.html');
      process.exit(1);
    }
    
    try {
      // Verificar se os v√≠deos existem
      await fs.access(desktopVideo);
      await fs.access(mobileVideo);
      
      // Processar com m√∫ltiplas resolu√ß√µes
      await extractor.processVideoResponsive(desktopVideo, mobileVideo, videoName, options);
      
      console.log('\n‚ú® Frames responsivos gerados com sucesso!');
      console.log('üí° As m√∫ltiplas resolu√ß√µes otimizam o carregamento para cada dispositivo');
      
    } catch (error) {
      if (error.code === 'ENOENT') {
        console.error(`‚ùå Arquivo n√£o encontrado: ${error.path}`);
      } else {
        console.error('\n‚ùå Falha:', error.message);
      }
      process.exit(1);
    }
    
    process.exit(0);
  }

  // Listar v√≠deos dispon√≠veis
  if (args[0] === '--list-videos') {
    const extractor = new FrameExtractor();
    const { videosDir, files, pairs, error } = await extractor.listAvailableVideos();
    
    if (error) {
      console.log(`‚ùå ${error}`);
      console.log('\nüí° Crie a pasta: mkdir -p static/videos');
      process.exit(1);
    }
    
    if (files.length === 0) {
      console.log('üìÅ Pasta static/videos est√° vazia.');
      console.log('\nüí° Adicione seus v√≠deos com nomes como:');
      console.log('   exemplo_desktop.mp4 + exemplo_mobile.mp4');
      console.log('   ou');
      console.log('   exemplo_wide.mp4 + exemplo_vertical.mp4');
      process.exit(0);
    }
    
    console.log('\nüìÅ V√çDEOS DISPON√çVEIS EM static/videos/\n');
    console.log('=' .repeat(60));
    
    let pairCount = 0;
    for (const [baseName, files] of pairs) {
      if (files.desktop && files.mobile) {
        pairCount++;
        console.log(`\n‚úÖ ${pairCount}. ${baseName}`);
        console.log(`   Desktop: ${files.desktop}`);
        console.log(`   Mobile:  ${files.mobile}`);
      }
    }
    
    // Listar v√≠deos sem par
    console.log('\n' + '-'.repeat(60));
    let orphanCount = 0;
    for (const [baseName, files] of pairs) {
      if (!files.desktop || !files.mobile) {
        orphanCount++;
        if (orphanCount === 1) console.log('\n‚ö†Ô∏è  V√çDEOS SEM PAR:');
        console.log(`   ${baseName}:`);
        if (files.desktop) console.log(`     ‚úì Desktop: ${files.desktop}`);
        else console.log(`     ‚úó Desktop: faltando`);
        if (files.mobile) console.log(`     ‚úì Mobile: ${files.mobile}`);
        else console.log(`     ‚úó Mobile: faltando`);
        if (files.unknown) console.log(`     ? Arquivo: ${files.unknown} (tipo n√£o identificado)`);
      }
    }
    
    if (pairCount > 0) {
      console.log('\n' + '=' .repeat(60));
      console.log(`\nüí° Para processar todos os ${pairCount} pares:`);
      console.log('   node extract-frames.js --process-all');
      console.log('\nüí° Para processar um espec√≠fico:');
      console.log('   node extract-frames.js static/videos/[nome]_desktop.mp4 static/videos/[nome]_mobile.mp4 [nome]');
      console.log('\nüÜï Para processar com m√∫ltiplas resolu√ß√µes:');
      console.log('   node extract-frames.js --responsive static/videos/[nome]_desktop.mp4 static/videos/[nome]_mobile.mp4 [nome]');
    }
    
    process.exit(0);
  }

  // Processar todos os v√≠deos
  if (args[0] === '--process-all') {
    const extractor = new FrameExtractor();
    
    // Parse de op√ß√µes globais
    const options = {
      fps: 15,
      quality: 85
    };
    
    const fpsIndex = args.indexOf('--fps');
    if (fpsIndex > -1 && args[fpsIndex + 1]) {
      options.fps = parseInt(args[fpsIndex + 1]);
    }
    
    const qualityIndex = args.indexOf('--quality');
    if (qualityIndex > -1 && args[qualityIndex + 1]) {
      options.quality = parseInt(args[qualityIndex + 1]);
    }

    // Aceitar overrides de scale
    const desktopScaleIndex = args.indexOf('--desktop-scale');
    if (desktopScaleIndex > -1 && args[desktopScaleIndex + 1]) {
      options.desktopScale = args[desktopScaleIndex + 1];
    }
    const mobileScaleIndex = args.indexOf('--mobile-scale');
    if (mobileScaleIndex > -1 && args[mobileScaleIndex + 1]) {
      options.mobileScale = args[mobileScaleIndex + 1];
    }
    
    console.log('üé¨ PROCESSAMENTO EM LOTE');
    console.log(`‚öôÔ∏è  Configura√ß√£o: ${options.fps} FPS, ${options.quality}% qualidade\n`);
    
    const results = await extractor.processAllVideos(options);
    
    if (results.length === 0) {
      console.log('Nenhum par de v√≠deos para processar.');
      process.exit(0);
    }
    
    // Resumo final
    console.log('\n' + '=' .repeat(60));
    console.log('üìä RESUMO DO PROCESSAMENTO');
    console.log('=' .repeat(60));
    
    const successful = results.filter(r => !r.error);
    const failed = results.filter(r => r.error);
    
    console.log(`\n‚úÖ Sucesso: ${successful.length}`);
    successful.forEach(r => {
      console.log(`   ${r.name}`);
    });
    
    if (failed.length > 0) {
      console.log(`\n‚ùå Falhas: ${failed.length}`);
      failed.forEach(r => {
        console.log(`   ${r.name}: ${r.error}`);
      });
    }
    
    console.log('\n‚ú® Processamento em lote conclu√≠do!');
    process.exit(0);
  }

  // Listar processados
  if (args[0] === '--list') {
    const extractor = new FrameExtractor();
    const processed = await extractor.listProcessed();
    
    if (processed.length === 0) {
      console.log('Nenhum v√≠deo processado ainda.');
    } else {
      console.log('\nüì¶ V√çDEOS PROCESSADOS:\n');
      processed.forEach((item, i) => {
        console.log(`${i + 1}. ${item.originalName || item.name}`);
        if (item.desktop) {
          console.log(`   Desktop: ${item.desktop.frameCount} frames`);
          console.log(`   Mobile: ${item.mobile.frameCount} frames`);
          console.log(`   Processado: ${item.processedAt || 'N/A'}`);
        }
        // üÜï Mostrar se tem vers√£o responsiva
        if (item.responsive) {
          console.log(`   üÜï Responsivo: ${item.breakpoints.desktop.length + item.breakpoints.mobile.length} resolu√ß√µes`);
        }
      });
    }
    process.exit(0);
  }

  // Validar argumentos
  if (args.length < 3) {
    console.error('‚ùå Uso: node extract-frames.js <desktop.mp4> <mobile.mp4> <nome>');
    console.error('   Ou: node extract-frames.js --responsive <desktop.mp4> <mobile.mp4> <nome>');
    process.exit(1);
  }

  const desktopVideo = args[0];
  const mobileVideo = args[1];
  const videoName = args[2];

  // Parse de op√ß√µes
  const options = {
    fps: 15,
    quality: 85,
    desktopScale: '1920:-2',
    mobileScale: '768:-2'
  };

  // Buscar valores das op√ß√µes
  const fpsIndex = args.indexOf('--fps');
  if (fpsIndex > -1 && args[fpsIndex + 1]) {
    options.fps = parseInt(args[fpsIndex + 1]);
  }

  const qualityIndex = args.indexOf('--quality');
  if (qualityIndex > -1 && args[qualityIndex + 1]) {
    options.quality = parseInt(args[qualityIndex + 1]);
  }

  const desktopScaleIndex = args.indexOf('--desktop-scale');
  if (desktopScaleIndex > -1 && args[desktopScaleIndex + 1]) {
    options.desktopScale = args[desktopScaleIndex + 1];
  }

  const mobileScaleIndex = args.indexOf('--mobile-scale');
  if (mobileScaleIndex > -1 && args[mobileScaleIndex + 1]) {
    options.mobileScale = args[mobileScaleIndex + 1];
  }

  // Executar
  const extractor = new FrameExtractor();

  // Verificar ffmpeg
  const hasFFmpeg = await extractor.checkFFmpeg();
  if (!hasFFmpeg) {
    console.error('‚ùå FFmpeg n√£o encontrado!');
    console.error('   Mac: brew install ffmpeg');
    console.error('   Linux: sudo apt install ffmpeg');
    console.error('   Windows: https://ffmpeg.org/download.html');
    process.exit(1);
  }

  try {
    // Verificar se os v√≠deos existem
    try {
      await fs.access(desktopVideo);
    } catch {
      console.error(`‚ùå V√≠deo desktop n√£o encontrado: ${desktopVideo}`);
      process.exit(1);
    }

    try {
      await fs.access(mobileVideo);
    } catch {
      console.error(`‚ùå V√≠deo mobile n√£o encontrado: ${mobileVideo}`);
      process.exit(1);
    }

    // Processar
    await extractor.processVideoPair(desktopVideo, mobileVideo, videoName, options);

    console.log('\n‚ú® Pronto! Frames extra√≠dos com sucesso.');
    console.log('üí° Use as configura√ß√µes acima no seu componente ScrollyFrames');
    console.log('\nüÜï Para gerar m√∫ltiplas resolu√ß√µes, use:');
    console.log(`   node extract-frames.js --responsive ${desktopVideo} ${mobileVideo} ${videoName}`);

  } catch (error) {
    console.error('\n‚ùå Falha:', error.message);
    process.exit(1);
  }
}

// Executar se chamado diretamente
if (process.argv[1] === fileURLToPath(import.meta.url)) {
  main();
}

// Exportar classe
export default FrameExtractor;